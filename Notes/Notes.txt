1. Интерфейс vs Абстрактный класс
Интерфейс описывает роль (Damageable, CarryingEntity, Tradeable).

Абстрактный класс задаёт базу для схожих сущностей (Character).
Интерфейс → «Что объект умеет делать?»

Абстрактный класс → «Кто он и что у него есть по умолчанию?»
Когда использовать интерфейс

Когда нужен только контракт (например: «любой, кто может получать урон, должен иметь Health и метод TakeDamage»).

Когда разные классы могут реализовать поведение по-разному, и общего кода нет.

Для слабой связанности: интерфейсы позволяют писать код, который работает с «чем-то, что умеет…», не зная деталей.

➡ Пример: IDamageable у нас именно контракт. Игра может иметь игроков, монстров, даже разрушаемые объекты (бочки, сундуки) — все они «повреждаемые», но устроены по-разному.
Когда использовать абстрактный класс

Когда у нескольких классов есть общие поля и общая логика, но при этом мы не хотим дублировать её в каждом классе.

Когда хочется дать базовый функционал, который можно расширять.

➡ Пример: Character мог бы содержать:

Name, Health, MaxHealth, AttackPower, Defense, IsAlive.

Общие методы: TakeDamage(), CheckDeath(), Heal().

Тогда Player и Monster унаследуются от Character, получат всё это «из коробки» и переопределят только то, что им нужно.
2. Принципы и философия ООП

Инкапсуляция

Скрываем внутренние детали объекта и предоставляем только безопасный и понятный интерфейс.

Пример: Inventory знает свой вес, а игрок не может просто “забрать” список предметов напрямую, он использует методы AddItem/RemoveItem.

Абстракция

Мы концентрируемся только на том, что важно для взаимодействия с объектом, не вдаваясь в детали реализации.

Пример: игроку не важно, как Inventory считает вес, ему важно, что он может добавить предмет, если позволяет максимальный вес.

Наследование

Позволяет создавать новые классы на основе существующих, расширяя их функциональность.

Пример: Player → AdminPlayer с дополнительными правами; Weapon → Sword и Bow.

Полиморфизм

Объекты могут вести себя по-разному в зависимости от конкретной реализации, но использоваться единообразно.

Пример: метод Use() у Potion и у Weapon работает по-разному, но вызывается одинаково: item.Use().
Философия в целом:

Моделируем мир через объекты, как в реальной жизни.

Делаем код читаемым, расширяемым и безопасным.

Стараемся снизить зависимость между частями программы, чтобы изменения в одной части не ломали всю систему.