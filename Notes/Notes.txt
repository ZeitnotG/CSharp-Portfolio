Интерфейс описывает роль (Damageable, CarryingEntity, Tradeable).

Абстрактный класс задаёт базу для схожих сущностей (Character).
Интерфейс → «Что объект умеет делать?»

Абстрактный класс → «Кто он и что у него есть по умолчанию?»
Когда использовать интерфейс

Когда нужен только контракт (например: «любой, кто может получать урон, должен иметь Health и метод TakeDamage»).

Когда разные классы могут реализовать поведение по-разному, и общего кода нет.

Для слабой связанности: интерфейсы позволяют писать код, который работает с «чем-то, что умеет…», не зная деталей.

➡ Пример: IDamageable у нас именно контракт. Игра может иметь игроков, монстров, даже разрушаемые объекты (бочки, сундуки) — все они «повреждаемые», но устроены по-разному.
Когда использовать абстрактный класс

Когда у нескольких классов есть общие поля и общая логика, но при этом мы не хотим дублировать её в каждом классе.

Когда хочется дать базовый функционал, который можно расширять.

➡ Пример: Character мог бы содержать:

Name, Health, MaxHealth, AttackPower, Defense, IsAlive.

Общие методы: TakeDamage(), CheckDeath(), Heal().

Тогда Player и Monster унаследуются от Character, получат всё это «из коробки» и переопределят только то, что им нужно.